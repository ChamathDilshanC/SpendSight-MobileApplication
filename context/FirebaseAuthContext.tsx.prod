import appleAuth from "@invertase/react-native-apple-authentication";
import { GoogleSignin } from "@react-native-google-signin/google-signin";
import {
  createUserWithEmailAndPassword,
  User as FirebaseUser,
  GoogleAuthProvider,
  OAuthProvider,
  onAuthStateChanged,
  signInWithCredential,
  signInWithEmailAndPassword,
  signOut,
  updateProfile,
} from "firebase/auth";
import { doc, getDoc, setDoc, Timestamp, updateDoc } from "firebase/firestore";
import React, {
  createContext,
  ReactNode,
  useContext,
  useEffect,
  useReducer,
} from "react";
import { Platform } from "react-native";
import { auth, db }  from "@/firebase";
import {
  AuthContextType,
  AuthState,
  User,
  UserLoginData,
  UserRegistrationData,
} from "../types/user";

// Configure Google Sign-In
GoogleSignin.configure({
  webClientId:
    "45937352137-vp1234567890abcdefghijklmnopqrst.apps.googleusercontent.com", // This needs to be generated in Firebase Console
  offlineAccess: true,
});

// Initial state
const initialAuthState: AuthState = {
  user: null,
  isAuthenticated: false,
  isLoading: true, // Start with true to check existing auth state
  error: null,
};

// Action types
type AuthAction =
  | { type: "SET_LOADING"; payload: boolean }
  | { type: "SET_ERROR"; payload: string | null }
  | { type: "LOGIN_SUCCESS"; payload: User }
  | { type: "LOGOUT" }
  | { type: "UPDATE_USER"; payload: Partial<User> }
  | { type: "CLEAR_ERROR" };

// Reducer
const authReducer = (state: AuthState, action: AuthAction): AuthState => {
  switch (action.type) {
    case "SET_LOADING":
      return { ...state, isLoading: action.payload };

    case "SET_ERROR":
      return { ...state, error: action.payload, isLoading: false };

    case "LOGIN_SUCCESS":
      return {
        ...state,
        user: action.payload,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      };

    case "LOGOUT":
      return {
        ...initialAuthState,
        isLoading: false,
      };

    case "UPDATE_USER":
      return {
        ...state,
        user: state.user ? { ...state.user, ...action.payload } : null,
      };

    case "CLEAR_ERROR":
      return { ...state, error: null };

    default:
      return state;
  }
};

// Create context
const AuthContext = createContext<AuthContextType | null>(null);

// Helper function to convert Firebase user to our User type
const convertFirebaseUser = async (
  firebaseUser: FirebaseUser,
  additionalData?: any
): Promise<User> => {
  const userDoc = await getDoc(doc(db, "users", firebaseUser.uid));
  const userData = userDoc.data();

  return {
    id: firebaseUser.uid,
    fullName: userData?.fullName || firebaseUser.displayName || "",
    email: firebaseUser.email || "",
    profilePicture:
      userData?.profilePicture || firebaseUser.photoURL || undefined,
    dateJoined: userData?.dateJoined
      ? userData.dateJoined.toDate()
      : new Date(),
    isActive: true,
    authProvider:
      additionalData?.authProvider || userData?.authProvider || "email",
    preferences: userData?.preferences || {
      currency: "USD",
      notifications: true,
      darkMode: true,
    },
  };
};

// Helper function to save user to Firestore
const saveUserToFirestore = async (user: User): Promise<void> => {
  await setDoc(
    doc(db, "users", user.id),
    {
      fullName: user.fullName,
      email: user.email,
      profilePicture: user.profilePicture,
      dateJoined: Timestamp.fromDate(user.dateJoined),
      isActive: user.isActive,
      authProvider: user.authProvider,
      preferences: user.preferences,
    },
    { merge: true }
  );
};

// Validation functions
const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const validatePassword = (password: string): boolean => {
  return password.length >= 6;
};

// Provider component
export const AuthProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const [authState, dispatch] = useReducer(authReducer, initialAuthState);

  // Listen to Firebase auth state changes
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (firebaseUser) {
        try {
          const user = await convertFirebaseUser(firebaseUser);
          dispatch({ type: "LOGIN_SUCCESS", payload: user });
        } catch (error) {
          console.error("Error converting Firebase user:", error);
          dispatch({ type: "SET_ERROR", payload: "Failed to load user data" });
        }
      } else {
        dispatch({ type: "LOGOUT" });
      }
    });

    return unsubscribe;
  }, []);

  // Register function
  const register = async (
    registrationData: UserRegistrationData
  ): Promise<boolean> => {
    try {
      dispatch({ type: "SET_LOADING", payload: true });
      dispatch({ type: "CLEAR_ERROR" });

      const { fullName, email, password, confirmPassword } = registrationData;

      // Validation
      if (!fullName.trim()) {
        dispatch({ type: "SET_ERROR", payload: "Full name is required" });
        return false;
      }

      if (!validateEmail(email)) {
        dispatch({
          type: "SET_ERROR",
          payload: "Please enter a valid email address",
        });
        return false;
      }

      if (!validatePassword(password)) {
        dispatch({
          type: "SET_ERROR",
          payload: "Password must be at least 6 characters long",
        });
        return false;
      }

      if (password !== confirmPassword) {
        dispatch({ type: "SET_ERROR", payload: "Passwords do not match" });
        return false;
      }

      // Create user with Firebase
      const userCredential = await createUserWithEmailAndPassword(
        auth,
        email,
        password
      );

      // Update display name
      await updateProfile(userCredential.user, {
        displayName: fullName,
      });

      // Create user document in Firestore
      const newUser: User = {
        id: userCredential.user.uid,
        fullName: fullName.trim(),
        email: email.toLowerCase(),
        dateJoined: new Date(),
        isActive: true,
        authProvider: "email",
        preferences: {
          currency: "USD",
          notifications: true,
          darkMode: true,
        },
      };

      await saveUserToFirestore(newUser);

      return true;
    } catch (error: any) {
      console.error("Registration error:", error);
      let errorMessage = "Registration failed. Please try again.";

      if (error.code === "auth/email-already-in-use") {
        errorMessage = "An account with this email already exists";
      } else if (error.code === "auth/weak-password") {
        errorMessage = "Password is too weak";
      } else if (error.code === "auth/invalid-email") {
        errorMessage = "Invalid email address";
      }

      dispatch({ type: "SET_ERROR", payload: errorMessage });
      return false;
    }
  };

  // Login function
  const login = async (loginData: UserLoginData): Promise<boolean> => {
    try {
      dispatch({ type: "SET_LOADING", payload: true });
      dispatch({ type: "CLEAR_ERROR" });

      const { email, password } = loginData;

      // Validation
      if (!validateEmail(email)) {
        dispatch({
          type: "SET_ERROR",
          payload: "Please enter a valid email address",
        });
        return false;
      }

      if (!password) {
        dispatch({ type: "SET_ERROR", payload: "Password is required" });
        return false;
      }

      // Sign in with Firebase
      await signInWithEmailAndPassword(auth, email, password);

      return true;
    } catch (error: any) {
      console.error("Login error:", error);
      let errorMessage = "Login failed. Please try again.";

      if (error.code === "auth/user-not-found") {
        errorMessage = "No account found with this email address";
      } else if (error.code === "auth/wrong-password") {
        errorMessage = "Incorrect password";
      } else if (error.code === "auth/invalid-email") {
        errorMessage = "Invalid email address";
      } else if (error.code === "auth/too-many-requests") {
        errorMessage = "Too many failed attempts. Please try again later.";
      }

      dispatch({ type: "SET_ERROR", payload: errorMessage });
      return false;
    }
  };

  // Google Sign-In function
  const signInWithGoogle = async (): Promise<boolean> => {
    try {
      dispatch({ type: "SET_LOADING", payload: true });
      dispatch({ type: "CLEAR_ERROR" });

      // Check if device supports Google Play
      await GoogleSignin.hasPlayServices({
        showPlayServicesUpdateDialog: true,
      });

      // Get user info from Google
      const userInfo = await GoogleSignin.signIn();

      // Get tokens
      const tokens = await GoogleSignin.getTokens();

      // Create a Google credential with the token
      const googleCredential = GoogleAuthProvider.credential(tokens.idToken);

      // Sign-in the user with the credential
      const userCredential = await signInWithCredential(auth, googleCredential);

      // Create or update user document in Firestore
      const existingUser = await convertFirebaseUser(userCredential.user, {
        authProvider: "google",
      });
      await saveUserToFirestore(existingUser);

      return true;
    } catch (error: any) {
      console.error("Google Sign-In error:", error);

      let errorMessage = "Google Sign-In failed";
      if (error.code === "auth/account-exists-with-different-credential") {
        errorMessage =
          "An account already exists with this email using a different sign-in method";
      } else if (error.code === "auth/cancelled-popup-request") {
        errorMessage = "Sign-in was cancelled";
      }

      dispatch({ type: "SET_ERROR", payload: errorMessage });
      return false;
    }
  };

  // Apple Sign-In function (iOS only)
  const signInWithApple = async (): Promise<boolean> => {
    try {
      if (Platform.OS !== "ios") {
        dispatch({
          type: "SET_ERROR",
          payload: "Apple Sign-In is only available on iOS",
        });
        return false;
      }

      dispatch({ type: "SET_LOADING", payload: true });
      dispatch({ type: "CLEAR_ERROR" });

      // Start the sign-in request
      const appleAuthRequestResponse = await appleAuth.performRequest({
        requestedOperation: appleAuth.Operation.LOGIN,
        requestedScopes: [appleAuth.Scope.EMAIL, appleAuth.Scope.FULL_NAME],
      });

      // Ensure Apple returned a user identityToken
      if (!appleAuthRequestResponse.identityToken) {
        dispatch({
          type: "SET_ERROR",
          payload: "Apple Sign-In failed - no identity token",
        });
        return false;
      }

      // Create a Firebase credential from the response
      const { identityToken, nonce } = appleAuthRequestResponse;
      const appleCredential = new OAuthProvider("apple.com").credential({
        idToken: identityToken,
        rawNonce: nonce,
      });

      // Sign-in the user with the credential
      const userCredential = await signInWithCredential(auth, appleCredential);

      // Create or update user document in Firestore
      let displayName = "";
      if (appleAuthRequestResponse.fullName) {
        displayName =
          `${appleAuthRequestResponse.fullName.givenName || ""} ${appleAuthRequestResponse.fullName.familyName || ""}`.trim();
      }

      // Update the Firebase user's display name if we got one from Apple
      if (displayName && !userCredential.user.displayName) {
        await updateProfile(userCredential.user, { displayName });
      }

      const existingUser = await convertFirebaseUser(userCredential.user, {
        authProvider: "apple",
      });
      await saveUserToFirestore(existingUser);

      return true;
    } catch (error: any) {
      console.error("Apple Sign-In error:", error);

      let errorMessage = "Apple Sign-In failed";
      if (error.code === "auth/account-exists-with-different-credential") {
        errorMessage =
          "An account already exists with this email using a different sign-in method";
      } else if (error.code === "1001") {
        errorMessage = "Apple Sign-In was cancelled";
      }

      dispatch({ type: "SET_ERROR", payload: errorMessage });
      return false;
    }
  };

  // Logout function
  const logout = async (): Promise<void> => {
    try {
      await signOut(auth);
      await GoogleSignin.signOut(); // Also sign out from Google
    } catch (error) {
      console.error("Logout error:", error);
    }
  };

  // Clear error function
  const clearError = (): void => {
    dispatch({ type: "CLEAR_ERROR" });
  };

  // Update user function
  const updateUser = async (userData: Partial<User>): Promise<void> => {
    try {
      if (!authState.user) return;

      const updatedUser = { ...authState.user, ...userData };

      // Update in Firestore
      await updateDoc(doc(db, "users", updatedUser.id), {
        ...userData,
        dateJoined: userData.dateJoined
          ? Timestamp.fromDate(userData.dateJoined)
          : undefined,
      });

      dispatch({ type: "UPDATE_USER", payload: userData });
    } catch (error) {
      console.error("Update user error:", error);
      dispatch({ type: "SET_ERROR", payload: "Failed to update user profile" });
    }
  };

  const contextValue: AuthContextType = {
    authState,
    login,
    register,
    signInWithGoogle,
    signInWithApple,
    logout,
    clearError,
    updateUser,
  };

  return (
    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>
  );
};

// Custom hook to use auth context
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
